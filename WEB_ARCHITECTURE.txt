# АРХИТЕКТУРА ВЕБ-СИСТЕМЫ АНАЛИТИКИ МАГАЗИНОВ

## 1. ОБЩАЯ СТРУКТУРА СИСТЕМЫ

### ТЕКУЩЕЕ СОСТОЯНИЕ:
- Генерация статичного HTML-файла из Excel
- Запуск скрипта на локальном компьютере
- Открытие в браузере

### НОВАЯ АРХИТЕКТУРА:
```
┌─────────────────────────────────────────────────────────────┐
│                    ВЕБ-БРАУЗЕРЫ ПОЛЬЗОВАТЕЛЕЙ               │
│              (Chrome, Firefox на компьютерах сети)          │
└──────────────────────┬──────────────────────────────────────┘
                       │ HTTP/HTTPS
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                    ВЕБ-СЕРВЕР (FRONTEND)                    │
│  - Nginx / Apache для статики                               │
│  - React / Vue.js интерфейс                                 │
│  - Дашборды с графиками (Plotly.js)                        │
└──────────────────────┬──────────────────────────────────────┘
                       │ REST API / WebSocket
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                   СЕРВЕР ПРИЛОЖЕНИЙ (BACKEND)               │
│  - Python: FastAPI / Flask / Django                         │
│  - Обработка запросов                                       │
│  - Бизнес-логика                                            │
│  - Авторизация и аутентификация                            │
│  - Обработка Pandas DataFrame                               │
└──────────────────────┬──────────────────────────────────────┘
                       │ SQL / File I/O
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                    СЛОЙ ДАННЫХ (DATABASE)                   │
│  - PostgreSQL / MySQL - метаданные, пользователи, права    │
│  - Redis - кеш обработанных данных                         │
│  - Файловое хранилище - Excel файлы (или замена на БД)    │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. BACKEND (СЕРВЕР ПРИЛОЖЕНИЙ)

### ТЕХНОЛОГИИ:
**РЕКОМЕНДАЦИЯ: FastAPI + Python 3.10+**

### ПОЧЕМУ FastAPI:
- ✅ Быстрая разработка REST API
- ✅ Встроенная документация (Swagger)
- ✅ Асинхронность для множества пользователей
- ✅ Работает с Pandas напрямую
- ✅ Простая интеграция авторизации

### СТРУКТУРА BACKEND:
```
backend/
├── app/
│   ├── main.py                    # Точка входа FastAPI
│   ├── config.py                  # Настройки (БД, секреты)
│   │
│   ├── api/                       # REST API endpoints
│   │   ├── auth.py                # Авторизация (login/logout)
│   │   ├── dashboards.py          # Получение дашбордов
│   │   ├── data.py                # Загрузка данных
│   │   └── charts.py              # Генерация графиков
│   │
│   ├── core/                      # Бизнес-логика
│   │   ├── data_processor.py      # Ваш текущий код обработки
│   │   ├── dashboard_engine.py    # Генератор дашбордов
│   │   └── charts/                # Ваши графики
│   │
│   ├── models/                    # Модели БД
│   │   ├── user.py                # Модель пользователя
│   │   ├── role.py                # Модель роли
│   │   └── permission.py          # Модель прав доступа
│   │
│   ├── services/                  # Сервисы
│   │   ├── auth_service.py        # Логика авторизации
│   │   ├── data_service.py        # Загрузка данных
│   │   └── cache_service.py       # Кеширование
│   │
│   └── middleware/                # Промежуточное ПО
│       ├── auth_middleware.py     # Проверка токенов
│       └── role_middleware.py     # Проверка прав
│
├── data/                          # Хранилище данных
│   ├── excel/                     # Excel файлы (временно)
│   └── processed/                 # Обработанные данные
│
└── requirements.txt               # Зависимости Python
```

### ОСНОВНЫЕ ФУНКЦИИ BACKEND:

**1. АВТОРИЗАЦИЯ И АУТЕНТИФИКАЦИЯ:**
```
- Login/Logout
- JWT токены для сессий
- Проверка прав доступа перед каждым запросом
- Хранение пользователей в БД
```

**2. ОБРАБОТКА ДАННЫХ:**
```
- Чтение Excel файлов (или запросы к БД)
- Применение фильтров от пользователя
- Агрегация данных через Pandas
- Кеширование результатов в Redis
```

**3. ГЕНЕРАЦИЯ ГРАФИКОВ:**
```
- Используем ваш код из charts/
- Возвращаем JSON данные для Plotly.js
- Не генерируем HTML на сервере!
- Frontend сам рендерит графики
```

**4. API ENDPOINTS (ПРИМЕРЫ):**
```
POST   /api/auth/login              # Вход
POST   /api/auth/logout             # Выход
GET    /api/user/info               # Информация о пользователе

GET    /api/dashboards              # Список доступных дашбордов
GET    /api/dashboards/{id}         # Конкретный дашборд

POST   /api/data/filter             # Применить фильтры к данным
GET    /api/charts/{chart_id}       # Получить данные графика
POST   /api/charts/generate         # Сгенерировать график с параметрами
```

---

## 3. FRONTEND (ВЕБ-ИНТЕРФЕЙС)

### ТЕХНОЛОГИИ:
**РЕКОМЕНДАЦИЯ: React + Plotly.js**

### СТРУКТУРА FRONTEND:
```
frontend/
├── src/
│   ├── App.js                     # Главный компонент
│   ├── index.js                   # Точка входа
│   │
│   ├── pages/                     # Страницы
│   │   ├── LoginPage.js           # Страница входа
│   │   ├── DashboardPage.js       # Главная страница дашборда
│   │   └── NotFoundPage.js        # 404
│   │
│   ├── components/                # Компоненты
│   │   ├── Header.js              # Шапка сайта
│   │   ├── Sidebar.js             # Боковое меню
│   │   ├── FilterPanel.js         # Панель фильтров
│   │   ├── ChartContainer.js      # Контейнер графика
│   │   └── TabPanel.js            # Вкладки
│   │
│   ├── services/                  # Сервисы для API
│   │   ├── api.js                 # HTTP клиент (axios)
│   │   ├── authService.js         # Авторизация
│   │   └── dataService.js         # Работа с данными
│   │
│   ├── store/                     # Управление состоянием
│   │   ├── authStore.js           # Состояние авторизации
│   │   └── dataStore.js           # Состояние данных
│   │
│   └── utils/                     # Утилиты
│       └── chartHelpers.js        # Помощники для графиков
│
├── public/
│   ├── index.html                 # HTML шаблон
│   └── assets/                    # Статика (CSS, изображения)
│
└── package.json                   # Зависимости JS
```

### ОСНОВНЫЕ ФУНКЦИИ FRONTEND:

**1. ОТОБРАЖЕНИЕ ДАШБОРДА:**
```
- Получает данные из Backend API
- Рендерит графики с помощью Plotly.js
- Динамическое обновление при изменении фильтров
- Адаптивная верстка (работает на всех устройствах)
```

**2. АВТОРИЗАЦИЯ:**
```
- Форма входа (логин/пароль)
- Сохранение JWT токена в localStorage
- Автоматический редирект на login при отсутствии токена
- Logout кнопка
```

**3. ФИЛЬТРЫ:**
```
- Те же фильтры что у вас: Магазин, Товар, Тип, Год, Месяц
- Применение фильтров отправляет запрос на Backend
- Backend возвращает отфильтрованные данные
- Графики перерисовываются
```

---

## 4. ДАННЫЕ И ХРАНИЛИЩЕ

### ВАРИАНТЫ ХРАНЕНИЯ ДАННЫХ:

### ВАРИАНТ A: EXCEL ФАЙЛЫ (ТЕКУЩИЙ ПОДХОД)
```
Плюсы:
✅ Не нужно менять процесс загрузки данных
✅ Быстрый старт
✅ Просто обновлять (заменить файл)

Минусы:
❌ Медленная работа при большом объеме
❌ Каждый раз читать весь файл
❌ Нет параллельного доступа
❌ Нет истории изменений

КАК РАБОТАЕТ:
1. Excel файлы лежат в /backend/data/excel/
2. Backend читает их через Pandas при запросе
3. Кеширует обработанные данные в Redis (1-24 часа)
4. При обновлении файла - очистить кеш
```

### ВАРИАНТ B: БАЗА ДАННЫХ (РЕКОМЕНДУЕТСЯ)
```
Плюсы:
✅ Быстрые запросы (индексы, оптимизация)
✅ Фильтрация на уровне БД (WHERE, GROUP BY)
✅ Масштабируемость
✅ История изменений
✅ Параллельный доступ

Минусы:
❌ Нужно мигрировать Excel → БД
❌ Настройка БД

КАК РАБОТАЕТ:
1. Импортируете Excel → PostgreSQL таблицы
2. Backend делает SQL запросы вместо Pandas
3. Pandas используется только для сложной аналитики
4. Кеш в Redis для готовых агрегаций
```

### РЕКОМЕНДУЕМАЯ СХЕМА БД:
```sql
-- Таблица продаж
CREATE TABLE sales (
    id SERIAL PRIMARY KEY,
    магазин VARCHAR(100),
    товар VARCHAR(200),
    тип VARCHAR(50),
    год INT,
    месяц INT,
    выручка DECIMAL(15, 2),
    количество INT,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sales_shop ON sales(магазин);
CREATE INDEX idx_sales_product ON sales(товар);
CREATE INDEX idx_sales_date ON sales(год, месяц);

-- Таблица магазинов
CREATE TABLE stores (
    id SERIAL PRIMARY KEY,
    название VARCHAR(100) UNIQUE,
    площадь DECIMAL(10, 2),
    адрес TEXT
);

-- Таблица чеков
CREATE TABLE checks (
    id SERIAL PRIMARY KEY,
    магазин VARCHAR(100),
    год INT,
    месяц INT,
    тип VARCHAR(50),
    чеки_по_типу INT,
    чеки_всего INT
);
```

### ГИБРИДНЫЙ ПОДХОД (ОПТИМАЛЬНЫЙ СТАРТ):
```
1. СНАЧАЛА: Используем Excel + Pandas
2. ПОТОМ: Постепенно мигрируем на БД

ЭТАПЫ:
- Этап 1: Excel файлы + агрессивное кеширование
- Этап 2: Импорт исторических данных в БД
- Этап 3: Новые данные сразу в БД
- Этап 4: Полный переход на БД
```

---

## 5. АВТОРИЗАЦИЯ И РАЗГРАНИЧЕНИЕ ДОСТУПА

### МОДЕЛЬ РОЛЕЙ (RBAC - Role-Based Access Control):

```
РОЛЬ               ПРАВА ДОСТУПА
─────────────────────────────────────────────────────
Администратор      - Полный доступ ко всем данным
                   - Управление пользователями
                   - Загрузка новых данных
                   - Все дашборды и отчеты

Руководитель       - Просмотр всех дашбордов
                   - Экспорт отчетов
                   - Фильтрация по всем параметрам
                   - НЕТ: управления пользователями

Менеджер           - Просмотр дашбордов своего региона/магазина
                   - Фильтрация только по своим данным
                   - Базовые отчеты

Аналитик           - Просмотр всех аналитических графиков
                   - Углубленная аналитика
                   - Экспорт данных

Пользователь       - Только базовые дашборды
(read-only)        - Без экспорта
                   - Без фильтров
```

### ТАБЛИЦЫ БД ДЛЯ АВТОРИЗАЦИИ:

```sql
-- Пользователи
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,  -- bcrypt hash
    full_name VARCHAR(100),
    email VARCHAR(100),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Роли
CREATE TABLE roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,      -- admin, manager, analyst
    description TEXT
);

-- Связь пользователь-роль (many-to-many)
CREATE TABLE user_roles (
    user_id INT REFERENCES users(id),
    role_id INT REFERENCES roles(id),
    PRIMARY KEY (user_id, role_id)
);

-- Права доступа
CREATE TABLE permissions (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE,              -- view_dashboard, export_data
    description TEXT
);

-- Связь роль-право
CREATE TABLE role_permissions (
    role_id INT REFERENCES roles(id),
    permission_id INT REFERENCES permissions(id),
    PRIMARY KEY (role_id, permission_id)
);

-- Ограничения по магазинам (для менеджеров)
CREATE TABLE user_store_access (
    user_id INT REFERENCES users(id),
    магазин VARCHAR(100),
    PRIMARY KEY (user_id, магазин)
);
```

### ЛОГИКА ПРОВЕРКИ ПРАВ В КОДЕ:

```python
# Backend: middleware/auth_middleware.py

def check_permission(user, permission_name):
    """Проверка права доступа"""
    # Получить роли пользователя
    roles = get_user_roles(user.id)

    # Проверить есть ли право у любой из ролей
    for role in roles:
        if has_permission(role, permission_name):
            return True

    return False

def filter_data_by_access(user, df):
    """Фильтровать данные по доступу пользователя"""
    # Если администратор - все данные
    if user_has_role(user, 'admin'):
        return df

    # Если менеджер - только свои магазины
    if user_has_role(user, 'manager'):
        allowed_stores = get_user_stores(user.id)
        return df[df['Магазин'].isin(allowed_stores)]

    # По умолчанию - все данные
    return df
```

---

## 6. РАЗВЕРТЫВАНИЕ В КОРПОРАТИВНОЙ СЕТИ

### АРХИТЕКТУРА СЕРВЕРА:

```
┌────────────────────────────────────────────────────┐
│           СЕРВЕР (Linux/Windows Server)            │
│                                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │  NGINX (Веб-сервер)                          │ │
│  │  - Порт 80/443                               │ │
│  │  - Отдает статику React                     │ │
│  │  - Проксирует API → Backend                 │ │
│  └──────────────────────────────────────────────┘ │
│                      ↓                             │
│  ┌──────────────────────────────────────────────┐ │
│  │  BACKEND (FastAPI)                           │ │
│  │  - Порт 8000 (внутренний)                   │ │
│  │  - Обработка запросов                       │ │
│  │  - Pandas вычисления                        │ │
│  └──────────────────────────────────────────────┘ │
│                      ↓                             │
│  ┌──────────────────────────────────────────────┐ │
│  │  PostgreSQL (База данных)                    │ │
│  │  - Порт 5432 (внутренний)                   │ │
│  └──────────────────────────────────────────────┘ │
│                                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │  Redis (Кеш)                                 │ │
│  │  - Порт 6379 (внутренний)                   │ │
│  └──────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────┘
```

### ДОСТУП ПОЛЬЗОВАТЕЛЕЙ:

```
ШАГ 1: Пользователь в корпсети открывает браузер
ШАГ 2: Вводит адрес: http://analytics.company.local
ШАГ 3: NGINX отдает HTML/CSS/JS (React приложение)
ШАГ 4: React делает API запрос: /api/auth/login
ШАГ 5: NGINX проксирует → FastAPI Backend
ШАГ 6: Backend проверяет логин/пароль в PostgreSQL
ШАГ 7: Возвращает JWT токен
ШАГ 8: React сохраняет токен, делает запросы с токеном
ШАГ 9: Backend проверяет токен и права перед каждым запросом
```

### КОНФИГУРАЦИЯ NGINX:

```nginx
server {
    listen 80;
    server_name analytics.company.local;

    # Frontend (React)
    location / {
        root /var/www/frontend/build;
        try_files $uri /index.html;
    }

    # Backend API
    location /api/ {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Статика (CSS, JS, изображения)
    location /static/ {
        alias /var/www/frontend/build/static/;
    }
}
```

---

## 7. БЕЗОПАСНОСТЬ

### ЗАЩИТА ОТ УГРОЗ:

```
1. АВТОРИЗАЦИЯ:
   - Только пользователи корпсети
   - Логин/пароль + JWT токены
   - Автоматический logout через N часов

2. HTTPS:
   - Шифрование трафика
   - SSL сертификат для корпсети

3. SQL INJECTION:
   - ORM (SQLAlchemy) вместо сырых запросов
   - Валидация всех входных данных

4. XSS:
   - Sanitize HTML на Frontend
   - Content Security Policy

5. RATE LIMITING:
   - Ограничение запросов (100 req/min на пользователя)
   - Защита от DDoS

6. ЛОГИРОВАНИЕ:
   - Все действия пользователей в лог
   - Мониторинг подозрительной активности
```

---

## 8. ПРОИЗВОДИТЕЛЬНОСТЬ

### ОПТИМИЗАЦИЯ ДЛЯ МНОЖЕСТВА ПОЛЬЗОВАТЕЛЕЙ:

```
1. КЕШИРОВАНИЕ:
   Redis:
   - Кеш обработанных данных (TTL 1 час)
   - Кеш графиков (TTL 30 мин)
   - Очистка при загрузке новых данных

2. АСИНХРОННОСТЬ:
   FastAPI:
   - Async/await для параллельных запросов
   - 100+ пользователей одновременно

3. ОПТИМИЗАЦИЯ PANDAS:
   - Не загружать весь DataFrame
   - Фильтровать данные на уровне БД (SQL WHERE)
   - Pandas только для финальной агрегации

4. LAZY LOADING:
   Frontend:
   - Загружать графики по мере прокрутки
   - Не грузить все вкладки сразу

5. CDN ДЛЯ СТАТИКИ:
   - Plotly.js из CDN (не в bundle)
   - Ускорение загрузки
```

### МОНИТОРИНГ:

```
- Grafana + Prometheus: метрики сервера
- Логи: ELK Stack (Elasticsearch, Logstash, Kibana)
- Alerting: уведомления при падении сервиса
```

---

## 9. ПРОЦЕСС ОБНОВЛЕНИЯ ДАННЫХ

### ВАРИАНТ A: РУЧНАЯ ЗАГРУЗКА EXCEL

```
ШАГ 1: Администратор заходит на сайт
ШАГ 2: Переходит в раздел "Загрузка данных"
ШАГ 3: Выбирает Excel файл (final_flat_clean.xlsx)
ШАГ 4: Backend:
       - Валидирует формат
       - Читает через Pandas
       - Сохраняет в БД (или заменяет файл)
       - Очищает кеш Redis
ШАГ 5: Данные обновлены, пользователи видят новые графики
```

### ВАРИАНТ B: АВТОМАТИЧЕСКАЯ ЗАГРУЗКА

```
ШАГ 1: Скрипт на сервере следит за папкой
ШАГ 2: При появлении нового файла:
       - Автоматически импортирует в БД
       - Очищает кеш
       - Отправляет уведомление админу
ШАГ 3: Данные обновлены без ручных действий
```

### ВАРИАНТ C: ИНТЕГРАЦИЯ С 1C / ERP

```
ШАГ 1: 1C выгружает данные в формате XML/CSV
ШАГ 2: Backend API endpoint: POST /api/data/import
ШАГ 3: Backend читает файл, импортирует в БД
ШАГ 4: Данные обновляются в реальном времени
```

---

## 10. ПОЭТАПНЫЙ ПЛАН ВНЕДРЕНИЯ

### ЭТАП 1: MVP (1-2 недели разработки)
```
✅ Backend:
   - FastAPI с базовыми endpoints
   - Чтение Excel файлов
   - Один дашборд (revenue_dynamics)
   - Простая авторизация (login/logout)

✅ Frontend:
   - React с одной страницей
   - Отображение одного графика
   - Форма входа

✅ Деплой:
   - Установка на тестовый сервер
   - Доступ для 5-10 пользователей
```

### ЭТАП 2: РАСШИРЕНИЕ (2-3 недели)
```
✅ Backend:
   - Все графики из текущего проекта
   - Фильтры (Магазин, Товар, Год, Месяц)
   - Кеширование в Redis
   - Ролевая модель (3 роли)

✅ Frontend:
   - Все дашборды и вкладки
   - Панель фильтров
   - Экспорт данных (CSV, Excel)

✅ Деплой:
   - Production сервер
   - Доступ для всех пользователей
```

### ЭТАП 3: ОПТИМИЗАЦИЯ (1-2 недели)
```
✅ Backend:
   - Миграция Excel → PostgreSQL
   - Оптимизация запросов
   - Логирование и мониторинг

✅ Frontend:
   - Улучшение UX
   - Мобильная версия
   - Темная тема

✅ Инфраструктура:
   - HTTPS
   - Автоматические бэкапы
   - Alerting
```

---

## 11. ИТОГОВАЯ РЕКОМЕНДАЦИЯ

### СТЕК ТЕХНОЛОГИЙ:

```
FRONTEND:  React + Plotly.js + Axios
BACKEND:   FastAPI + Pandas + SQLAlchemy
DATABASE:  PostgreSQL
CACHE:     Redis
SERVER:    Linux + Nginx + Gunicorn
```

### ОТКУДА ЧИТАТЬ ДАННЫЕ:

```
СЕЙЧАС (MVP):
- Excel файлы в /backend/data/excel/
- Backend читает через Pandas
- Кеширование в Redis

ПОТОМ (PRODUCTION):
- PostgreSQL база данных
- SQL запросы для фильтрации
- Pandas только для сложной аналитики
- Redis для кеша агрегаций
```

### ГДЕ ДОЛЖНА БЫТЬ СИСТЕМА:

```
ВАРИАНТ 1: ВЫДЕЛЕННЫЙ СЕРВЕР
- Физический/виртуальный сервер в вашей сети
- Linux (Ubuntu/CentOS)
- IP: 192.168.X.X (внутренняя сеть)
- DNS: analytics.company.local

ВАРИАНТ 2: КОНТЕЙНЕРЫ (DOCKER)
- Docker + Docker Compose
- Изоляция компонентов
- Легкое масштабирование
- Простое обновление

ВАРИАНТ 3: ОБЛАКО (если есть доступ)
- Частное облако компании
- Kubernetes для оркестрации
- Автоматическое масштабирование
```

---

## 12. СЛЕДУЮЩИЕ ШАГИ

1. ОБСУДИТЬ:
   - Сколько пользователей ожидается? (10? 100? 1000?)
   - Есть ли сервер для развертывания?
   - Текущий процесс обновления данных?
   - Приоритет: быстрый старт или масштабируемость?

2. ВЫБРАТЬ ПОДХОД:
   - MVP с Excel файлами (быстро)
   - Полноценная система с БД (медленнее, но правильно)

3. НАЧАТЬ РАЗРАБОТКУ:
   - Настроить проект (Backend + Frontend)
   - Миграция текущего кода
   - Тестирование
   - Развертывание
